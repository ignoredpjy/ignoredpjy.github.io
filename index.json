[{"content":"使用git之前 git 的 配置文件有三个 分别是 system、global、local\nsystem 位于‪C:\\Program Files\\Git\\etc\\gitconfig为所有用户配置文件（linux 系统位于 /etc/gitconfig） global 位于~\\gitconfig 为用户配置文件 local 位于 .\\.git\\gitconfig 为当前项目配置文件 其实还有 --worktree 作用域 : 使用每个工作树的配置文件\n一般，修改 \u0026ndash;global\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 man git config | git config --help # 显示当前作用域的Git配置、附带作用域、附带配置文件位置 $ git config --list| -l --show-scope --show-origin # 直接编辑Git配置文件，不推荐 $ git config -e [--global] # 设置提交代码时的用户信息 git config --global --add user.name \u0026#34;pjy\u0026#34; #--add可省略，删除用 unset git config --global user.email \u0026#34;email\u0026#34; git config --global corlor.ui true #彩色ui git config --global core.editor vim #默认编辑器 git config --global core.ignorecase true #文件名不区分大小写 # 类Unix操作系统使用的是大小写敏感的文件系统， # 而Windows和Mac OS X（默认安装）的文件系统则是大小写不敏感的文件系统。 # README、readme以及Readme文件，在Linux等操作系统上访问的是不同的文件， # 而在Windows和Mac OS X上则指向同一个文件。 # 在Windows和Mac OS X平台上执行git clone后， # 文件会发生覆盖导致丢失 git config --global core.autocrlf input # LF（Unix风格的换行符） CRLF（Windows风格的换行符） # 我们一般希望远程仓库中的代码为LF 所以input，开发环境为win的话，true也行 # core.autocrlf 是一个Git的配置项，它有三个可选值： # true：在checkout时自动将行尾转换为CRLF，在commit时自动将行尾转换为LF。 # input：在检出代码时不自动转换行尾，在提交代码时自动将行尾转换为LF。 # false：在check和commit代码时都不自动转换行尾。 更多配置项详见 官网\n仓库初始化 1 2 3 git init git clone [https|ssh] .gitignore\n基本每个仓库都含有的忽略文件，用来配置 git 忽略哪些文件\n常需要忽略一些 集成开发环境配置目录 和 代码打包目录\n查看的命令 常用的一些查看详情的命令\n最常用\n1 2 3 4 5 # 显示有变更的文件 工作区、暂存区、是否发生冲突 $ git status # 显示当前分支的最近几次提交 $ git reflog 代码比较diff\n1 2 3 4 5 6 7 8 9 10 11 # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] git log 和 blame\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\u0026#34;提交说明\u0026#34;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline 其他\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示今天你写了多少行代码 $ git diff --shortstat \u0026#34;@{0 day ago}\u0026#34; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] 奇怪的符号 1 2 3 4 5 6 7 HEAD # 当前分支最新版本 HEAD^^ # 有几个^就是前几个版本 HEAD~[0-n] #数字代替^的个数 git checkout - # - 表示上一次指向的版本，后退操作 git checkout -- . # -- 无意义可省略 ‘.’表示全部文件 origin/ # 远程分支名称的前缀 FETCH_HEAD # 含义见下文 远程同步 提交前的操作（暂存区） 创建、修改 、删除文件\nadd 本质是 同步工作区的变化到暂存区，使暂存区和工作区保持一致。\n当工作区新创建文件 1.txt时，add可以将文件添加到暂存区。之后，如果工作区删除1.txt时，使用add可以将该文件从暂存区也删除。\n1 2 3 4 5 6 7 8 9 10 # 添加当前目录的所有文件到暂存区 git add . # 添加指定文件到暂存区 git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 git add [dir] # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 git add -p 灵活的删除文件\n1 2 3 4 5 6 # 删除工作区文件，并且将这次删除同步暂存区, # 如果删除时工作区和暂存区文件内容不一致，需要 -f git rm -f [file1] [file2] ... # 暂存区停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] 重命名文件\n1 2 # 移动或改名文件，并且将这个改名放入暂存区，文件名重复时-f强制 $ git mv -f [file-original] [file-renamed] 提交前的撤销 注意：还原工作区前，确保当前工作区的内容已彻底无用\n工作区 ——》 暂存区\n注意：checkout命令 是 文件内容还原 ，会创建不存在的文件，但不会删除工作区文件，git status 可以看到 那些标红的文件\n本质可以理解为: 将 暂存区文件 复制粘贴到 工作区\n1 2 3 4 # -- 可以省略，推荐省略，有返回结果，加了--就没有，怪 git checkout -- [.|file｜dir] git restore [.|file] #功能完全同上 工作区 ——》 最新版本\n无法单独还原工作区，确实也没必要，工作区还原了，暂存区还有必要保留吗，如果有，为什么不直接还原成暂存区\n暂存区 ——》 最新版本\n1 2 3 4 # --mixed 为默认，可以省略，用于重置暂存区 -\u0026gt; HEAD版本，但不改变工作区，不带[file]则重置全部文件 git reset --mixed HEAD [file] git restore --staged [.|file] #功能完全同上 工作区和暂存区 ——》最新版本\n1 2 3 git checkout HEAD -- [file|dir] # 推荐省略--，理由同上 # restore上面两个指令都用一遍，就行了 结合上面三种来看:\n推荐使用 restore 命令，Git 2.23 版本新引入，相比checkout 表意更清晰。而 reset的实现，则属于是reset的附带功能了\nreset 和 HEAD 一起使用可以做到版本内的撤销操作，但 reset的本职工作是版本的删除回退（危险操作）\n提交后的撤销（版本回退） reset 除了预设的 mixed 模式外，另外还有soft 和hard 模式。欲了解各模式的影响程度，请参照下面的表格。\n模式名称 HEAD的位置 索引 工作目录 指定文件 soft 修改 不修改 不修改 不可 mixed 修改 修改 不修改 可以 hard 修改 修改 修改 不可 安全的回退 ,使用 revert 命令\n相比 reset，revert 不会删除任何提交记录\n假设 版本链：A — B — C— D— E\nreset 回到 C：A — B — C\nrevert回到 C：A — B — C— D— E — C\npush 之前 的 commit 可以用 reset，已push的commit 一定用revert\n因为，本地操作失误的reset，可以用 reflog 抢救\n提交操作 1 2 3 4 5 # add . + commit ,携带message $ git commit -am [message] # 覆盖上一次提交并重写message，不会增加提交次数，好用 $ git commit --amend -am [message] 易混淆的checkout 与 restore 、reset 、switch checkout 功能理解: 其实就是查看代码，把代码转移到工作区来查看\n1 2 3 4 5 6 7 8 9 git checkout -- [file] #查看暂存区代码 git checkout [commit_id] file #查看指定版本代码 git checkout -b [branch_name] #查看其他分支代码，也就是切换分支，-b是新建分支并切换 git checkout - #回退到上次查看的版本 git checkout tags/\u0026lt;tag-name\u0026gt; #查看tag版本 因为查看代码会修改工作区，就导致checkout具有撤销工作区的功能\nreset 之前已经讲过，回退版本的功能会修改工作区和暂存区，所以和Head搭配，也具有部分撤销功能\nswitch 和restore 是Git 2.23 版本引入，用来清晰化 checkout 功能类型的新命令。\nswitch: 更清晰地切换分支。\n1 2 3 git switch -c \u0026lt;branch_name\u0026gt; #切换分支 -c 是创建分支 git switch - git switch tags/\u0026lt;tag-name\u0026gt; restore 恢复或撤销文件的更改。\n1 git restore --source=\u0026lt;commit\u0026gt; \u0026lt;file\u0026gt; # restore 也有查看指定版本代码的功能 这两个命令都有 checkout的影子\n分支同步 新建分支，除了上面提到的checkout 和 switch，还有 branch命令\n1 2 3 4 5 git branch [branch_name] git checkout -b [branch_name] git switch -c \u0026lt;branch_name\u0026gt; 删除，重命名分支\n1 2 git branch -d [branch_name] git branch -m [old] [new] 查看所有分支、切换分支\n1 2 3 4 git branch --list -avv # --list 可省略，-a 远程分支，-v 附带id和message ,-vv 再附带与远程分支的对应关系 git checkout [branch_name] origin/\u0026lt;branch_name\u0026gt; # 使用 origin 可以下拉本地没有的远程分支 git switch [branch_name] 合并和冲突\n1 2 3 4 5 git merge [other_branch] # git status 查看冲突在哪个文件 # 手动修改文件 # 用 git add 告诉 Git 文件冲突已经解决 merge 和 rebase\n远程同步 设置远程仓库\n1 2 3 4 5 git remote -v #查看远程仓库 一般会有两个相同url（fetch \u0026amp; push） git remote add [http|ssh] git remote rename git remote remove 设置本地分支与远程分支的对应关系\n1 2 3 4 git branch (--set-upstream-to=\u0026lt;upstream\u0026gt; | -u \u0026lt;upstream\u0026gt;) [\u0026lt;branchname\u0026gt;] git branch --unset-upstream [\u0026lt;branchname\u0026gt;] git push [-u|--set-upstream] \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; # push时顺带set git fetch\n无参数默认下拉当前head对应的远程分支，并不会下拉全部分支\ngit pull\ngit pull = git fetch + git merge FETCH_HEAD\npush之前必须pull，push -f也必须先pull\npull 时可能会发生冲突，同 merge操作\ngit push\ngit push -f 操作需要远程仓库关闭分支保护功能\n在本地创建分支来下拉远程的某个分支\n1 2 3 4 5 git checkout -b \u0026lt;branch_name\u0026gt; origin/\u0026lt;branch_name\u0026gt; #等同于 git fetch origin \u0026lt;branch_name\u0026gt; git checkout -b \u0026lt;branch_name\u0026gt; FETCH_HEAD FETCH_HEAD\n待续\ntag标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] starch 1 2 3 git stash git pull git stash pop| git stash apply git stash pop 命令会在 stash 应用之后丢弃（默认情况下指的是最顶部的）stash，而 git stash apply 会将其保留在存储列表中，以备日后重用（或者您可以在之后使用 git stash drop 命令移除此 stash）。\n除非 git stash pop 之后存在冲突，在这种情况下，它将不会删除该 stash，而使其行为与git stash apply 的命令完全相同。\n我们也可以使用另一种方式来实现 git stash pop，那就是：git stash apply \u0026amp;\u0026amp; git stash drop。\n拓展知识点\n到这我们基本实现了上述需求，但还需要知道一些基本的 git stash 知识，方便我们更清楚的操作。\n下列命令可以查看缓存的列表：\n1 2 git stash list 复制代码 有时我们会发现因冲突导致 git stash pop 命令并没有消除 list 的记录，这样对我们操作造成一些干扰，这时我我们可以执行以下操作，清除记录：\n1 git stash drop 我们还可以对缓存的代码进行标识，方便查看：\n1 git stash save [stashMessage] 当缓存了很多条记录的时候，我们还可以一键清除：\n1 git stash clear cherry-pick git cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。\n1 2 3 4 5 6 7 8 #某提交应用于当前分支 git cherry-pick [commitHash] #多个提交 git cherry-pick \u0026lt;HashA\u0026gt; \u0026lt;HashB\u0026gt; #上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。 git cherry-pick A..B #注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。 git cherry-pick A^..B 如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。\n（1）--continue\n用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。\n1 $ git cherry-pick --continue （2）--abort\n发生代码冲突后，放弃合并，回到操作前的样子。\n（3）--quit\n发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。\nworktree 待续\n子模块 待续\n","permalink":"https://ignoredpjy.github.io/posts/study/git%E6%8C%87%E5%8D%97/","summary":"使用git之前 git 的 配置文件有三个 分别是 system、global、local\nsystem 位于‪C:\\Program Files\\Git\\etc\\gitconfig为所有用户配置文件（linux 系统位于 /etc/gitconfig） global 位于~\\gitconfig 为用户配置文件 local 位于 .\\.git\\gitconfig 为当前项目配置文件 其实还有 --worktree 作用域 : 使用每个工作树的配置文件\n一般，修改 \u0026ndash;global\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 man git config | git config --help # 显示当前作用域的Git配置、附带作用域、附带配置文件位置 $ git config --list| -l --show-scope --show-origin # 直接编辑Git配置文件，不推荐 $ git config -e [--global] # 设置提交代码时的用户信息 git config --global --add user.","title":"Git指南"}]